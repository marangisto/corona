#pragma once

////
//
//      STM32G0 VREFBUF peripherals
//
///

// VREFBUF: System configuration controller

struct stm32g030_vrefbuf_t
{
    volatile uint32_t CSR; // VREFBUF control and status register
    volatile uint32_t CCR; // VREFBUF calibration control register

    static constexpr uint32_t CSR_RESET_VALUE = 0x2; // Reset value
    static constexpr uint32_t CSR_ENVR = 0x1; // Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.
    static constexpr uint32_t CSR_HIZ = 0x2; // High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to Table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration.
    static constexpr uint32_t CSR_VRR = 0x8; // Voltage reference buffer ready
    typedef bit_field_t<4, 0x7> CSR_VRS; // Voltage reference scale These bits select the value generated by the voltage reference buffer. Other: Reserved

    static constexpr uint32_t CCR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3f> CCR_TRIM; // Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage.
};

// VREFBUF: System configuration controller

struct stm32g051_vrefbuf_t
{
    volatile uint32_t CSR; // VREFBUF control and status register
    volatile uint32_t CCR; // VREFBUF calibration control register

    static constexpr uint32_t CSR_RESET_VALUE = 0x2; // Reset value
    static constexpr uint32_t CSR_ENVR = 0x1; // Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.
    static constexpr uint32_t CSR_HIZ = 0x2; // High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to for the mode descriptions depending on ENVR bit configuration.
    static constexpr uint32_t CSR_VRS = 0x4; // Voltage reference scale This bit selects the value generated by the voltage reference buffer.
    static constexpr uint32_t CSR_VRR = 0x8; // Voltage reference buffer ready

    static constexpr uint32_t CCR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3f> CCR_TRIM; // Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows the tuning of the internal reference buffer voltage.
};

template<>
struct peripheral_t<STM32G030, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32g030_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32G031, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32g030_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32G041, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32g030_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32G051, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32g051_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32G061, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32g051_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32G0B0, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32g051_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32G0B1, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32g051_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32G0C1, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32g051_vrefbuf_t;
    static T& V;
};

using vrefbuf_t = peripheral_t<svd, VREFBUF>;
