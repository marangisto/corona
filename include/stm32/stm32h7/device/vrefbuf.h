#pragma once

////
//
//      STM32H7 VREFBUF peripherals
//
///

// VREFBUF: VREFBUF

struct stm32h723_vrefbuf_t
{
    volatile uint32_t CSR; // VREFBUF control and status register
    volatile uint32_t CCR; // VREFBUF calibration control register

    static constexpr uint32_t CSR_RESET_VALUE = 0x2; // Reset value
    static constexpr uint32_t CSR_ENVR = 0x1; // Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.
    static constexpr uint32_t CSR_HIZ = 0x2; // High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to Table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration.
    static constexpr uint32_t CSR_VRR = 0x8; // Voltage reference buffer ready
    typedef bit_field_t<4, 0x7> CSR_VRS; // Voltage reference scale These bits select the value generated by the voltage reference buffer. Other: Reserved

    static constexpr uint32_t CCR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3f> CCR_TRIM; // Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage.
};

// VREFBUF: VREFBUF

struct stm32h750x_vrefbuf_t
{
    volatile uint32_t VREFBUF_CSR; // VREFBUF control and status register
    volatile uint32_t VREFBUF_CCR; // VREFBUF calibration control register

    static constexpr uint32_t VREFBUF_CSR_RESET_VALUE = 0x2; // Reset value
    static constexpr uint32_t VREFBUF_CSR_ENVR = 0x1; // Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.
    static constexpr uint32_t VREFBUF_CSR_HIZ = 0x2; // High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to Table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration.
    static constexpr uint32_t VREFBUF_CSR_VRR = 0x8; // Voltage reference buffer ready
    typedef bit_field_t<4, 0x7> VREFBUF_CSR_VRS; // Voltage reference scale These bits select the value generated by the voltage reference buffer. Other: Reserved

    static constexpr uint32_t VREFBUF_CCR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3f> VREFBUF_CCR_TRIM; // Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage.
};

template<>
struct peripheral_t<STM32H723, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h723_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32H725, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h723_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32H73x, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h723_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32H742x, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h723_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32H743, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h723_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32H745_CM4, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h723_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32H745_CM7, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h723_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32H747_CM4, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h723_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32H747_CM7, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h723_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32H753, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h723_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32H755_CM4, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h723_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32H755_CM7, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h723_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32H757_CM4, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h723_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32H757_CM7, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h723_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32H750x, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h750x_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32H7A3x, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h750x_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32H7B0x, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h750x_vrefbuf_t;
    static T& V;
};

template<>
struct peripheral_t<STM32H7B3x, VREFBUF>
{
    static constexpr periph_t P = VREFBUF;
    using T = stm32h750x_vrefbuf_t;
    static T& V;
};

using vrefbuf_t = peripheral_t<svd, VREFBUF>;
