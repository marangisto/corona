#pragma once

////
//
//      STM32U5 MDF peripherals
//
///

// MDF1: Multi-function digital filter

struct stm32u5xx_mdf1_t
{
    volatile uint32_t GCR; // MDF global control register
    volatile uint32_t CKGCR; // MDF clock generator control register
    reserved_t<0x1e> _0x8;
    volatile uint32_t MDF_SITF0CR; // This register is used to control the serial interfaces (SITFx).
    volatile uint32_t MDF_BSMX0CR; // This register is used to select the bitstream to be provided to the corresponding digital filter and to the SCD.
    volatile uint32_t MDF_DFLT0CR; // This register is used to control the digital filter x.
    volatile uint32_t MDF_DFLT0CICR; // This register is used to control the main CIC filter.
    volatile uint32_t MDF_DFLT0RSFR; // This register is used to control the reshape and HPF filters.
    volatile uint32_t MDF_DFLT0INTR; // This register is used to the integrator (INT) settings.
    volatile uint32_t MDF_OLD0CR; // This register is used to configure the Out-of Limit Detector function.
    volatile uint32_t MDF_OLD0THLR; // This register is used for the adjustment of the Out-off Limit low threshold.
    volatile uint32_t MDF_OLD0THHR; // This register is used for the adjustment of the Out-off Limit high threshold.
    volatile uint32_t MDF_DLY0CR; // This register is used for the adjustment stream delays.
    volatile uint32_t MDF_SCD0CR; // This register is used for the adjustment stream delays.
    volatile uint32_t MDF_DFLT0IER; // This register is used for allowing or not the events to generate an interrupt.
    volatile uint32_t MDF_DFLT0ISR; // MDF DFLT0 interrupt status register 0
    volatile uint32_t MDF_OEC0CR; // This register contains the offset compensation value.
    reserved_t<0xd> _0xb8;
    volatile uint32_t MDF_SNPS0DR; // This register is used to read the data processed by each digital filter in snapshot mode.
    volatile uint32_t MDF_DFLT0DR; // This register is used to read the data processed by each digital filter.
    reserved_t<0x3> _0xf4;
    volatile uint32_t MDF_SITF1CR; // This register is used to control the serial interfaces (SITFx).
    volatile uint32_t MDF_BSMX1CR; // This register is used to select the bitstream to be provided to the corresponding digital filter and to the SCD.
    volatile uint32_t MDF_DFLT1CR; // This register is used to control the digital filter x.
    volatile uint32_t MDF_DFLT1CICR; // This register is used to control the main CIC filter.
    volatile uint32_t MDF_DFLT1RSFR; // This register is used to control the reshape and HPF filters.
    volatile uint32_t MDF_DFLT1INTR; // This register is used to the integrator (INT) settings.
    volatile uint32_t MDF_OLD1CR; // This register is used to configure the Out-of Limit Detector function.
    volatile uint32_t MDF_OLD1THLR; // This register is used for the adjustment of the Out-off Limit low threshold.
    volatile uint32_t MDF_OLD1THHR; // This register is used for the adjustment of the Out-off Limit high threshold.
    volatile uint32_t MDF_DLY1CR; // This register is used for the adjustment stream delays.
    volatile uint32_t MDF_SCD1CR; // This register is used for the adjustment stream delays.
    volatile uint32_t MDF_DFLT1IER; // MDF DFLTx interrupt enable register x
    volatile uint32_t MDF_DFLT1ISR; // This register contains the status flags for each digital filter path.
    volatile uint32_t MDF_OEC1CR; // This register contains the offset compensation value.
    reserved_t<0xd> _0x138;
    volatile uint32_t MDF_SNPS1DR; // This register is used to read the data processed by each digital filter in snapshot mode.
    volatile uint32_t MDF_DFLT1DR; // This register is used to read the data processed by each digital filter.
    reserved_t<0x3> _0x174;
    volatile uint32_t MDF_SITF2CR; // This register is used to control the serial interfaces (SITFx).
    volatile uint32_t MDF_BSMX2CR; // This register is used to select the bitstream to be provided to the corresponding digital filter and to the SCD.
    volatile uint32_t MDF_DFLT2CR; // This register is used to control the digital filter 2.
    volatile uint32_t MDF_DFLT2CICR; // This register is used to control the main CIC filter.
    volatile uint32_t MDF_DFLT2RSFR; // This register is used to control the reshape and HPF filters.
    volatile uint32_t MDF_DFLT2INTR; // This register is used to the integrator (INT) settings.
    volatile uint32_t MDF_OLD2CR; // This register is used to configure the Out-of Limit Detector function.
    volatile uint32_t MDF_OLD2THLR; // This register is used for the adjustment of the Out-off Limit low threshold.
    volatile uint32_t MDF_OLD2THHR; // This register is used for the adjustment of the Out-off Limit high threshold.
    volatile uint32_t MDF_DLY2CR; // This register is used for the adjustment stream delays.
    volatile uint32_t MDF_SCD2CR; // This register is used for the adjustment stream delays.
    volatile uint32_t MDF_DFLT2IER; // MDF DFLTx interrupt enable register x
    volatile uint32_t MDF_DFLT2ISR; // This register contains the status flags for each digital filter path.
    volatile uint32_t MDF_OEC2CR; // This register contains the offset compensation value.
    reserved_t<0xd> _0x1b8;
    volatile uint32_t MDF_SNPS2DR; // This register is used to read the data processed by each digital filter in snapshot mode.
    volatile uint32_t MDF_DFLT2DR; // This register is used to read the data processed by each digital filter.
    reserved_t<0x3> _0x1f4;
    volatile uint32_t MDF_SITF3CR; // This register is used to control the serial interfaces (SITFx).
    volatile uint32_t MDF_BSMX3CR; // This register is used to select the bitstream to be provided to the corresponding digital filter and to the SCD.
    volatile uint32_t MDF_DFLT3CR; // This register is used to control the digital filter 3.
    volatile uint32_t MDF_DFLT3CICR; // This register is used to control the main CIC filter.
    volatile uint32_t MDF_DFLT3RSFR; // This register is used to control the reshape and HPF filters.
    volatile uint32_t MDF_DFLT3INTR; // This register is used to the integrator (INT) settings.
    volatile uint32_t MDF_OLD3CR; // This register is used to configure the Out-of Limit Detector function.
    volatile uint32_t MDF_OLD3THLR; // This register is used for the adjustment of the Out-off Limit low threshold.
    volatile uint32_t MDF_OLD3THHR; // This register is used for the adjustment of the Out-off Limit high threshold.
    volatile uint32_t MDF_DLY3CR; // This register is used for the adjustment stream delays.
    volatile uint32_t MDF_SCD3CR; // This register is used for the adjustment stream delays.
    volatile uint32_t MDF_DFLT3IER; // MDF DFLTx interrupt enable register x
    volatile uint32_t MDF_DFLT3ISR; // This register contains the status flags for each digital filter path.
    volatile uint32_t MDF_OEC3CR; // This register contains the offset compensation value.
    reserved_t<0xd> _0x238;
    volatile uint32_t MDF_SNPS3DR; // This register is used to read the data processed by each digital filter in snapshot mode.
    volatile uint32_t MDF_DFLT3DR; // This register is used to read the data processed by each digital filter.
    reserved_t<0x3> _0x274;
    volatile uint32_t MDF_SITF4CR; // This register is used to control the serial interfaces (SITFx).
    volatile uint32_t MDF_BSMX4CR; // This register is used to select the bitstream to be provided to the corresponding digital filter and to the SCD.
    volatile uint32_t MDF_DFLT4CR; // This register is used to control the digital filter 4.
    volatile uint32_t MDF_DFLT4CICR; // This register is used to control the main CIC filter.
    volatile uint32_t MDF_DFLT4RSFR; // This register is used to control the reshape and HPF filters.
    volatile uint32_t MDF_DFLT4INTR; // This register is used to the integrator (INT) settings.
    volatile uint32_t MDF_OLD4CR; // This register is used to configure the Out-of Limit Detector function.
    volatile uint32_t MDF_OLD4THLR; // This register is used for the adjustment of the Out-off Limit low threshold.
    volatile uint32_t MDF_OLD4THHR; // This register is used for the adjustment of the Out-off Limit high threshold.
    volatile uint32_t MDF_DLY4CR; // This register is used for the adjustment stream delays.
    volatile uint32_t MDF_SCD4CR; // This register is used for the adjustment stream delays.
    volatile uint32_t MDF_DFLT4IER; // MDF DFLTx interrupt enable register x
    volatile uint32_t MDF_DFLT4ISR; // This register contains the status flags for each digital filter path.
    volatile uint32_t MDF_OEC4CR; // This register contains the offset compensation value.
    reserved_t<0xd> _0x2b8;
    volatile uint32_t MDF_SNPS4DR; // This register is used to read the data processed by each digital filter in snapshot mode.
    volatile uint32_t MDF_DFLT4DR; // This register is used to read the data processed by each digital filter.
    reserved_t<0x3> _0x2f4;
    volatile uint32_t MDF_SITF5CR; // This register is used to control the serial interfaces (SITFx).
    volatile uint32_t MDF_BSMX5CR; // This register is used to select the bitstream to be provided to the corresponding digital filter and to the SCD.
    volatile uint32_t MDF_DFLT5CR; // This register is used to control the digital filter x.
    volatile uint32_t MDF_DFLT5CICR; // This register is used to control the main CIC filter.
    volatile uint32_t MDF_DFLT5RSFR; // This register is used to control the reshape and HPF filters.
    volatile uint32_t MDF_DFLT5INTR; // This register is used to the integrator (INT) settings.
    volatile uint32_t MDF_OLD5CR; // This register is used to configure the Out-of Limit Detector function.
    volatile uint32_t MDF_OLD5THLR; // This register is used for the adjustment of the Out-off Limit low threshold.
    volatile uint32_t MDF_OLD5THHR; // This register is used for the adjustment of the Out-off Limit high threshold.
    volatile uint32_t MDF_DLY5CR; // This register is used for the adjustment stream delays.
    volatile uint32_t MDF_SCD5CR; // This register is used for the adjustment stream delays.
    volatile uint32_t MDF_DFLT5IER; // MDF DFLTx interrupt enable register x
    volatile uint32_t MDF_DFLT5ISR; // This register contains the status flags for each digital filter path.
    volatile uint32_t MDF_OEC5CR; // This register contains the offset compensation value.
    reserved_t<0xd> _0x338;
    volatile uint32_t MDF_SNPS5DR; // This register is used to read the data processed by each digital filter in snapshot mode.
    volatile uint32_t MDF_DFLT5DR; // This register is used to read the data processed by each digital filter.

    static constexpr uint32_t GCR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t GCR_TRGO = 0x1; // TRGO
    typedef bit_field_t<4, 0xf> GCR_ILVNB; // ILVNB

    static constexpr uint32_t CKGCR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t CKGCR_CKGDEN = 0x1; // CKGDEN
    static constexpr uint32_t CKGCR_CCK0EN = 0x2; // CCK0EN
    static constexpr uint32_t CKGCR_CCK1EN = 0x4; // CCK1EN
    static constexpr uint32_t CKGCR_CKGMOD = 0x10; // CKGMOD
    static constexpr uint32_t CKGCR_CCK0DIR = 0x20; // CCK0DIR
    static constexpr uint32_t CKGCR_CCK1DIR = 0x40; // CCK1DIR
    static constexpr uint32_t CKGCR_TRGSENS = 0x100; // TRGSENS
    typedef bit_field_t<12, 0xf> CKGCR_TRGSRC; // TRGSRC
    typedef bit_field_t<16, 0xf> CKGCR_CCKDIV; // CCKDIV
    typedef bit_field_t<24, 0x7f> CKGCR_PROCDIV; // PROCDIV
    static constexpr uint32_t CKGCR_CKGACTIVE = 0x80000000; // CKGACTIVE


    static constexpr uint32_t MDF_SITF0CR_RESET_VALUE = 0x1f00; // Reset value
    static constexpr uint32_t MDF_SITF0CR_SITFEN = 0x1; // Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
    typedef bit_field_t<1, 0x3> MDF_SITF0CR_SCKSRC; // Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x3> MDF_SITF0CR_SITFMOD; // Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x1f> MDF_SITF0CR_STH; // Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_SITF0CR_SITFACTIVE = 0x80000000; // Serial interface Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the serial interface is effectively enabled (active) or not. The protected fields of this function can only be updated when the SITFACTIVE is set , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SITFEN and a transition on SITFACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The serial interface is not active, and can be configured if needed - 1: The serial interface is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_BSMX0CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x1f> MDF_BSMX0CR_BSSEL; // Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_BSMX0CR_BSMXACTIVE = 0x80000000; // BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_DFLT0CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT0CR_DFLTEN = 0x1; // Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
    static constexpr uint32_t MDF_DFLT0CR_DMAEN = 0x2; // DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT0CR_FTH = 0x4; // RXFIFO Threshold selection Set and cleared by software.
    typedef bit_field_t<4, 0x7> MDF_DFLT0CR_ACQMOD; // Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT0CR_TRGSENS = 0x100; // Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0xf> MDF_DFLT0CR_TRGSRC; // Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT0CR_SNPSFMT = 0x10000; // Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<20, 0xff> MDF_DFLT0CR_NBDIS; // Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT0CR_DFLTRUN = 0x40000000; // Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
    static constexpr uint32_t MDF_DFLT0CR_DFLTACTIVE = 0x80000000; // Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active

    static constexpr uint32_t MDF_DFLT0CICR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3> MDF_DFLT0CICR_DATSRC; // Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x7> MDF_DFLT0CICR_CICMOD; // Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x1ff> MDF_DFLT0CICR_MCICD; // CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<20, 0x3f> MDF_DFLT0CICR_SCALE; // Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits

    static constexpr uint32_t MDF_DFLT0RSFR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT0RSFR_RSFLTBYP = 0x1; // Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT0RSFR_RSFLTD = 0x10; // Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT0RSFR_HPFBYP = 0x80; // High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x3> MDF_DFLT0RSFR_HPFC; // High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_DFLT0INTR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3> MDF_DFLT0INTR_INTDIV; // Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x7f> MDF_DFLT0INTR_INTVAL; // Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_OLD0CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_OLD0CR_OLDEN = 0x1; // Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
    static constexpr uint32_t MDF_OLD0CR_THINB = 0x2; // Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0xf> MDF_OLD0CR_BKOLD; // Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0x3> MDF_OLD0CR_ACICN; // OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<17, 0x1f> MDF_OLD0CR_ACICD; // OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_OLD0CR_OLDACTIVE = 0x80000000; // OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_OLD0THLR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OLD0THLR_OLDTHL; // OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_OLD0THHR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OLD0THHR_OLDTHH; // OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details

    static constexpr uint32_t MDF_DLY0CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x7f> MDF_DLY0CR_SKPDLY; // Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
    static constexpr uint32_t MDF_DLY0CR_SKPBF = 0x80000000; // Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.

    static constexpr uint32_t MDF_SCD0CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_SCD0CR_SCDEN = 0x1; // Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
    typedef bit_field_t<4, 0xf> MDF_SCD0CR_BKSCD; // Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0xff> MDF_SCD0CR_SCDT; // Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_SCD0CR_SCDACTIVE = 0x80000000; // SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_DFLT0IER_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT0IER_FTHIE = 0x1; // RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
    static constexpr uint32_t MDF_DFLT0IER_DOVRIE = 0x2; // Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
    static constexpr uint32_t MDF_DFLT0IER_SSDRIE = 0x4; // Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
    static constexpr uint32_t MDF_DFLT0IER_OLDIE = 0x10; // Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
    static constexpr uint32_t MDF_DFLT0IER_SSOVRIE = 0x80; // Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
    static constexpr uint32_t MDF_DFLT0IER_SCDIE = 0x100; // Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
    static constexpr uint32_t MDF_DFLT0IER_SATIE = 0x200; // Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
    static constexpr uint32_t MDF_DFLT0IER_CKABIE = 0x400; // Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
    static constexpr uint32_t MDF_DFLT0IER_RFOVRIE = 0x800; // Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled

    static constexpr uint32_t MDF_DFLT0ISR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT0ISR_FTHF = 0x1; // FTHF
    static constexpr uint32_t MDF_DFLT0ISR_DOVRF = 0x2; // Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT0ISR_SSDRF = 0x4; // Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on , writing 0 has no effect. - 1: Reading 1 means that a new data is available on , writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT0ISR_RXNEF = 0x8; // RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
    static constexpr uint32_t MDF_DFLT0ISR_OLDF = 0x10; // Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
    static constexpr uint32_t MDF_DFLT0ISR_THLF = 0x20; // Low threshold status flag Set by hardware, and cleared by software by writing this bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was higher than OLDTHL when the last OLD event occurred. - 1: The signal was lower than OLDTHL when the last OLD event occurred.
    static constexpr uint32_t MDF_DFLT0ISR_THHF = 0x40; // High threshold status flag Set by hardware, and cleared by software by writing this bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH when the last OLD event occurred. - 1: The signal was higher than OLDTHH when the last OLD event occurred.
    static constexpr uint32_t MDF_DFLT0ISR_SSOVRF = 0x80; // Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT0ISR_SCDF = 0x100; // Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT0ISR_SATF = 0x200; // Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT0ISR_CKABF = 0x400; // Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT0ISR_RFOVRF = 0x800; // Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.

    static constexpr uint32_t MDF_OEC0CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OEC0CR_OFFSET; // Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.


    static constexpr uint32_t MDF_SNPS0DR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x1ff> MDF_SNPS0DR_MCICDC; // Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
    typedef bit_field_t<9, 0x7f> MDF_SNPS0DR_EXTSDR; // Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
    typedef bit_field_t<16, 0xffff> MDF_SNPS0DR_SDR; // Contains the 16 MSB of the last valid data processed by the digital filter.

    static constexpr uint32_t MDF_DFLT0DR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<8, 0xffffff> MDF_DFLT0DR_DR; // Data processed by digital filter.


    static constexpr uint32_t MDF_SITF1CR_RESET_VALUE = 0x1f00; // Reset value
    static constexpr uint32_t MDF_SITF1CR_SITFEN = 0x1; // Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
    typedef bit_field_t<1, 0x3> MDF_SITF1CR_SCKSRC; // Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x3> MDF_SITF1CR_SITFMOD; // Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x1f> MDF_SITF1CR_STH; // Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_SITF1CR_SITFACTIVE = 0x80000000; // Serial interface Active flag

    static constexpr uint32_t MDF_BSMX1CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x1f> MDF_BSMX1CR_BSSEL; // Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_BSMX1CR_BSMXACTIVE = 0x80000000; // BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_DFLT1CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT1CR_DFLTEN = 0x1; // Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
    static constexpr uint32_t MDF_DFLT1CR_DMAEN = 0x2; // DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT1CR_FTH = 0x4; // RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x7> MDF_DFLT1CR_ACQMOD; // Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT1CR_TRGSENS = 0x100; // Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0xf> MDF_DFLT1CR_TRGSRC; // Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT1CR_SNPSFMT = 0x10000; // Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<20, 0xff> MDF_DFLT1CR_NBDIS; // Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT1CR_DFLTRUN = 0x40000000; // Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
    static constexpr uint32_t MDF_DFLT1CR_DFLTACTIVE = 0x80000000; // Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active

    static constexpr uint32_t MDF_DFLT1CICR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3> MDF_DFLT1CICR_DATSRC; // Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x7> MDF_DFLT1CICR_CICMOD; // Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x1ff> MDF_DFLT1CICR_MCICD; // CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<20, 0x3f> MDF_DFLT1CICR_SCALE; // Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits

    static constexpr uint32_t MDF_DFLT1RSFR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT1RSFR_RSFLTBYP = 0x1; // Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT1RSFR_RSFLTD = 0x10; // Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT1RSFR_HPFBYP = 0x80; // High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x3> MDF_DFLT1RSFR_HPFC; // High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_DFLT1INTR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3> MDF_DFLT1INTR_INTDIV; // Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x7f> MDF_DFLT1INTR_INTVAL; // Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_OLD1CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_OLD1CR_OLDEN = 0x1; // Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
    static constexpr uint32_t MDF_OLD1CR_THINB = 0x2; // Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0xf> MDF_OLD1CR_BKOLD; // Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0x3> MDF_OLD1CR_ACICN; // OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<17, 0x1f> MDF_OLD1CR_ACICD; // OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_OLD1CR_OLDACTIVE = 0x80000000; // OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_OLD1THLR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OLD1THLR_OLDTHL; // OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_OLD1THHR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OLD1THHR_OLDTHH; // OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details

    static constexpr uint32_t MDF_DLY1CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x7f> MDF_DLY1CR_SKPDLY; // Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
    static constexpr uint32_t MDF_DLY1CR_SKPBF = 0x80000000; // Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.

    static constexpr uint32_t MDF_SCD1CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_SCD1CR_SCDEN = 0x1; // Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
    typedef bit_field_t<4, 0xf> MDF_SCD1CR_BKSCD; // Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0xff> MDF_SCD1CR_SCDT; // Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_SCD1CR_SCDACTIVE = 0x80000000; // SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_DFLT1IER_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT1IER_FTHIE = 0x1; // RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
    static constexpr uint32_t MDF_DFLT1IER_DOVRIE = 0x2; // Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
    static constexpr uint32_t MDF_DFLT1IER_SSDRIE = 0x4; // Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
    static constexpr uint32_t MDF_DFLT1IER_OLDIE = 0x10; // Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
    static constexpr uint32_t MDF_DFLT1IER_SSOVRIE = 0x80; // Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
    static constexpr uint32_t MDF_DFLT1IER_SCDIE = 0x100; // Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
    static constexpr uint32_t MDF_DFLT1IER_SATIE = 0x200; // Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
    static constexpr uint32_t MDF_DFLT1IER_CKABIE = 0x400; // Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
    static constexpr uint32_t MDF_DFLT1IER_RFOVRIE = 0x800; // Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled

    static constexpr uint32_t MDF_DFLT1ISR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT1ISR_FTHF = 0x1; // RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT1ISR_DOVRF = 0x2; // Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT1ISR_SSDRF = 0x4; // Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT1ISR_RXNEF = 0x8; // RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
    static constexpr uint32_t MDF_DFLT1ISR_OLDF = 0x10; // Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
    static constexpr uint32_t MDF_DFLT1ISR_THLF = 0x20; // Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
    static constexpr uint32_t MDF_DFLT1ISR_THHF = 0x40; // High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
    static constexpr uint32_t MDF_DFLT1ISR_SSOVRF = 0x80; // Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT1ISR_SCDF = 0x100; // Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT1ISR_SATF = 0x200; // Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT1ISR_CKABF = 0x400; // Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT1ISR_RFOVRF = 0x800; // Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.

    static constexpr uint32_t MDF_OEC1CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OEC1CR_OFFSET; // Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.


    static constexpr uint32_t MDF_SNPS1DR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x1ff> MDF_SNPS1DR_MCICDC; // Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
    typedef bit_field_t<9, 0x7f> MDF_SNPS1DR_EXTSDR; // Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
    typedef bit_field_t<16, 0xffff> MDF_SNPS1DR_SDR; // Contains the 16 MSB of the last valid data processed by the digital filter.

    static constexpr uint32_t MDF_DFLT1DR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<8, 0xffffff> MDF_DFLT1DR_DR; // Data processed by digital filter.


    static constexpr uint32_t MDF_SITF2CR_RESET_VALUE = 0x1f00; // Reset value
    static constexpr uint32_t MDF_SITF2CR_SITFEN = 0x1; // Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
    typedef bit_field_t<1, 0x3> MDF_SITF2CR_SCKSRC; // Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x3> MDF_SITF2CR_SITFMOD; // Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x1f> MDF_SITF2CR_STH; // Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_SITF2CR_SITFACTIVE = 0x80000000; // Serial interface Active flag

    static constexpr uint32_t MDF_BSMX2CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x1f> MDF_BSMX2CR_BSSEL; // Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_BSMX2CR_BSMXACTIVE = 0x80000000; // BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set to a . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set to in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_DFLT2CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT2CR_DFLTEN = 0x1; // Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
    static constexpr uint32_t MDF_DFLT2CR_DMAEN = 0x2; // DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT2CR_FTH = 0x4; // RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in a interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x7> MDF_DFLT2CR_ACQMOD; // Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT2CR_TRGSENS = 0x100; // Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0xf> MDF_DFLT2CR_TRGSRC; // Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT2CR_SNPSFMT = 0x10000; // Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<20, 0xff> MDF_DFLT2CR_NBDIS; // Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT2CR_DFLTRUN = 0x40000000; // Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
    static constexpr uint32_t MDF_DFLT2CR_DFLTACTIVE = 0x80000000; // Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active

    static constexpr uint32_t MDF_DFLT2CICR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3> MDF_DFLT2CICR_DATSRC; // Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x7> MDF_DFLT2CICR_CICMOD; // Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x1ff> MDF_DFLT2CICR_MCICD; // CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<20, 0x3f> MDF_DFLT2CICR_SCALE; // Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits

    static constexpr uint32_t MDF_DFLT2RSFR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT2RSFR_RSFLTBYP = 0x1; // Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT2RSFR_RSFLTD = 0x10; // Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT2RSFR_HPFBYP = 0x80; // High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x3> MDF_DFLT2RSFR_HPFC; // High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_DFLT2INTR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3> MDF_DFLT2INTR_INTDIV; // Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x7f> MDF_DFLT2INTR_INTVAL; // Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_OLD2CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_OLD2CR_OLDEN = 0x1; // Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
    static constexpr uint32_t MDF_OLD2CR_THINB = 0x2; // Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0xf> MDF_OLD2CR_BKOLD; // Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0x3> MDF_OLD2CR_ACICN; // OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<17, 0x1f> MDF_OLD2CR_ACICD; // OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_OLD2CR_OLDACTIVE = 0x80000000; // OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_OLD2THLR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OLD2THLR_OLDTHL; // OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_OLD2THHR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OLD2THHR_OLDTHH; // OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details

    static constexpr uint32_t MDF_DLY2CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x7f> MDF_DLY2CR_SKPDLY; // Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
    static constexpr uint32_t MDF_DLY2CR_SKPBF = 0x80000000; // Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.

    static constexpr uint32_t MDF_SCD2CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_SCD2CR_SCDEN = 0x1; // Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
    typedef bit_field_t<4, 0xf> MDF_SCD2CR_BKSCD; // Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0xff> MDF_SCD2CR_SCDT; // Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_SCD2CR_SCDACTIVE = 0x80000000; // SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_DFLT2IER_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT2IER_FTHIE = 0x1; // RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
    static constexpr uint32_t MDF_DFLT2IER_DOVRIE = 0x2; // Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
    static constexpr uint32_t MDF_DFLT2IER_SSDRIE = 0x4; // Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
    static constexpr uint32_t MDF_DFLT2IER_OLDIE = 0x10; // Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
    static constexpr uint32_t MDF_DFLT2IER_SSOVRIE = 0x80; // Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
    static constexpr uint32_t MDF_DFLT2IER_SCDIE = 0x100; // Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
    static constexpr uint32_t MDF_DFLT2IER_SATIE = 0x200; // Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
    static constexpr uint32_t MDF_DFLT2IER_CKABIE = 0x400; // Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
    static constexpr uint32_t MDF_DFLT2IER_RFOVRIE = 0x800; // Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled

    static constexpr uint32_t MDF_DFLT2ISR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT2ISR_FTHF = 0x1; // RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT2ISR_DOVRF = 0x2; // Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT2ISR_SSDRF = 0x4; // Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT2ISR_RXNEF = 0x8; // RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
    static constexpr uint32_t MDF_DFLT2ISR_OLDF = 0x10; // Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
    static constexpr uint32_t MDF_DFLT2ISR_THLF = 0x20; // Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
    static constexpr uint32_t MDF_DFLT2ISR_THHF = 0x40; // High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
    static constexpr uint32_t MDF_DFLT2ISR_SSOVRF = 0x80; // Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT2ISR_SCDF = 0x100; // Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT2ISR_SATF = 0x200; // Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT2ISR_CKABF = 0x400; // Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT2ISR_RFOVRF = 0x800; // Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.

    static constexpr uint32_t MDF_OEC2CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OEC2CR_OFFSET; // Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.


    static constexpr uint32_t MDF_SNPS2DR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x1ff> MDF_SNPS2DR_MCICDC; // Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
    typedef bit_field_t<9, 0x7f> MDF_SNPS2DR_EXTSDR; // Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
    typedef bit_field_t<16, 0xffff> MDF_SNPS2DR_SDR; // Contains the 16 MSB of the last valid data processed by the digital filter.

    static constexpr uint32_t MDF_DFLT2DR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<8, 0xffffff> MDF_DFLT2DR_DR; // Data processed by digital filter.


    static constexpr uint32_t MDF_SITF3CR_RESET_VALUE = 0x1f00; // Reset value
    static constexpr uint32_t MDF_SITF3CR_SITFEN = 0x1; // Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
    typedef bit_field_t<1, 0x3> MDF_SITF3CR_SCKSRC; // Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x3> MDF_SITF3CR_SITFMOD; // Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x1f> MDF_SITF3CR_STH; // Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_SITF3CR_SITFACTIVE = 0x80000000; // Serial interface Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the serial interface is effectively enabled (active) or not. The protected fields of this function can only be updated when the SITFACTIVE is set , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SITFEN and a transition on SITFACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The serial interface is not active, and can be configured if needed - 1: The serial interface is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_BSMX3CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x1f> MDF_BSMX3CR_BSSEL; // Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_BSMX3CR_BSMXACTIVE = 0x80000000; // BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set to a . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set to a in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_DFLT3CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT3CR_DFLTEN = 0x1; // Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
    static constexpr uint32_t MDF_DFLT3CR_DMAEN = 0x2; // DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT3CR_FTH = 0x4; // RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in a interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x7> MDF_DFLT3CR_ACQMOD; // Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT3CR_TRGSENS = 0x100; // Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0xf> MDF_DFLT3CR_TRGSRC; // Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT3CR_SNPSFMT = 0x10000; // Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<20, 0xff> MDF_DFLT3CR_NBDIS; // Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT3CR_DFLTRUN = 0x40000000; // Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
    static constexpr uint32_t MDF_DFLT3CR_DFLTACTIVE = 0x80000000; // Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active

    static constexpr uint32_t MDF_DFLT3CICR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3> MDF_DFLT3CICR_DATSRC; // Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x7> MDF_DFLT3CICR_CICMOD; // Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x1ff> MDF_DFLT3CICR_MCICD; // CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<20, 0x3f> MDF_DFLT3CICR_SCALE; // Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits

    static constexpr uint32_t MDF_DFLT3RSFR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT3RSFR_RSFLTBYP = 0x1; // Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT3RSFR_RSFLTD = 0x10; // Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT3RSFR_HPFBYP = 0x80; // High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x3> MDF_DFLT3RSFR_HPFC; // High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_DFLT3INTR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3> MDF_DFLT3INTR_INTDIV; // Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x7f> MDF_DFLT3INTR_INTVAL; // Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_OLD3CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_OLD3CR_OLDEN = 0x1; // Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
    static constexpr uint32_t MDF_OLD3CR_THINB = 0x2; // Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0xf> MDF_OLD3CR_BKOLD; // Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0x3> MDF_OLD3CR_ACICN; // OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<17, 0x1f> MDF_OLD3CR_ACICD; // OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_OLD3CR_OLDACTIVE = 0x80000000; // OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_OLD3THLR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OLD3THLR_OLDTHL; // OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_OLD3THHR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OLD3THHR_OLDTHH; // OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details

    static constexpr uint32_t MDF_DLY3CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x7f> MDF_DLY3CR_SKPDLY; // Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
    static constexpr uint32_t MDF_DLY3CR_SKPBF = 0x80000000; // Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.

    static constexpr uint32_t MDF_SCD3CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_SCD3CR_SCDEN = 0x1; // Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
    typedef bit_field_t<4, 0xf> MDF_SCD3CR_BKSCD; // Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0xff> MDF_SCD3CR_SCDT; // Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_SCD3CR_SCDACTIVE = 0x80000000; // SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_DFLT3IER_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT3IER_FTHIE = 0x1; // RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
    static constexpr uint32_t MDF_DFLT3IER_DOVRIE = 0x2; // Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
    static constexpr uint32_t MDF_DFLT3IER_SSDRIE = 0x4; // Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
    static constexpr uint32_t MDF_DFLT3IER_OLDIE = 0x10; // Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
    static constexpr uint32_t MDF_DFLT3IER_SSOVRIE = 0x80; // Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
    static constexpr uint32_t MDF_DFLT3IER_SCDIE = 0x100; // Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
    static constexpr uint32_t MDF_DFLT3IER_SATIE = 0x200; // Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
    static constexpr uint32_t MDF_DFLT3IER_CKABIE = 0x400; // Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
    static constexpr uint32_t MDF_DFLT3IER_RFOVRIE = 0x800; // Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled

    static constexpr uint32_t MDF_DFLT3ISR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT3ISR_FTHF = 0x1; // RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT3ISR_DOVRF = 0x2; // Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT3ISR_SSDRF = 0x4; // Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT3ISR_RXNEF = 0x8; // RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
    static constexpr uint32_t MDF_DFLT3ISR_OLDF = 0x10; // Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
    static constexpr uint32_t MDF_DFLT3ISR_THLF = 0x20; // Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
    static constexpr uint32_t MDF_DFLT3ISR_THHF = 0x40; // High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
    static constexpr uint32_t MDF_DFLT3ISR_SSOVRF = 0x80; // Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT3ISR_SCDF = 0x100; // Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT3ISR_SATF = 0x200; // Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT3ISR_CKABF = 0x400; // Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT3ISR_RFOVRF = 0x800; // Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.

    static constexpr uint32_t MDF_OEC3CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OEC3CR_OFFSET; // Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.


    static constexpr uint32_t MDF_SNPS3DR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x1ff> MDF_SNPS3DR_MCICDC; // Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
    typedef bit_field_t<9, 0x7f> MDF_SNPS3DR_EXTSDR; // Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
    typedef bit_field_t<16, 0xffff> MDF_SNPS3DR_SDR; // Contains the 16 MSB of the last valid data processed by the digital filter.

    static constexpr uint32_t MDF_DFLT3DR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<8, 0xffffff> MDF_DFLT3DR_DR; // Data processed by digital filter.


    static constexpr uint32_t MDF_SITF4CR_RESET_VALUE = 0x1f00; // Reset value
    static constexpr uint32_t MDF_SITF4CR_SITFEN = 0x1; // Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
    typedef bit_field_t<1, 0x3> MDF_SITF4CR_SCKSRC; // Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x3> MDF_SITF4CR_SITFMOD; // Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x1f> MDF_SITF4CR_STH; // Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_SITF4CR_SITFACTIVE = 0x80000000; // Serial interface Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the serial interface is effectively enabled (active) or not. The protected fields of this function can only be updated when the SITFACTIVE is set , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SITFEN and a transition on SITFACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The serial interface is not active, and can be configured if needed - 1: The serial interface is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_BSMX4CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x1f> MDF_BSMX4CR_BSSEL; // Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_BSMX4CR_BSMXACTIVE = 0x80000000; // BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set to . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set to in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_DFLT4CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT4CR_DFLTEN = 0x1; // Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
    static constexpr uint32_t MDF_DFLT4CR_DMAEN = 0x2; // DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT4CR_FTH = 0x4; // RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in a interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x7> MDF_DFLT4CR_ACQMOD; // Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT4CR_TRGSENS = 0x100; // Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0xf> MDF_DFLT4CR_TRGSRC; // Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT4CR_SNPSFMT = 0x10000; // Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<20, 0xff> MDF_DFLT4CR_NBDIS; // Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT4CR_DFLTRUN = 0x40000000; // Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
    static constexpr uint32_t MDF_DFLT4CR_DFLTACTIVE = 0x80000000; // Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active

    static constexpr uint32_t MDF_DFLT4CICR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3> MDF_DFLT4CICR_DATSRC; // Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x7> MDF_DFLT4CICR_CICMOD; // Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x1ff> MDF_DFLT4CICR_MCICD; // CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<20, 0x3f> MDF_DFLT4CICR_SCALE; // Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits

    static constexpr uint32_t MDF_DFLT4RSFR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT4RSFR_RSFLTBYP = 0x1; // Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT4RSFR_RSFLTD = 0x10; // Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT4RSFR_HPFBYP = 0x80; // High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x3> MDF_DFLT4RSFR_HPFC; // High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_DFLT4INTR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3> MDF_DFLT4INTR_INTDIV; // Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x7f> MDF_DFLT4INTR_INTVAL; // Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_OLD4CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_OLD4CR_OLDEN = 0x1; // Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
    static constexpr uint32_t MDF_OLD4CR_THINB = 0x2; // Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0xf> MDF_OLD4CR_BKOLD; // Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0x3> MDF_OLD4CR_ACICN; // OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<17, 0x1f> MDF_OLD4CR_ACICD; // OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_OLD4CR_OLDACTIVE = 0x80000000; // OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_OLD4THLR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OLD4THLR_OLDTHL; // OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_OLD4THHR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OLD4THHR_OLDTHH; // OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details

    static constexpr uint32_t MDF_DLY4CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x7f> MDF_DLY4CR_SKPDLY; // Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
    static constexpr uint32_t MDF_DLY4CR_SKPBF = 0x80000000; // Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.

    static constexpr uint32_t MDF_SCD4CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_SCD4CR_SCDEN = 0x1; // Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
    typedef bit_field_t<4, 0xf> MDF_SCD4CR_BKSCD; // Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0xff> MDF_SCD4CR_SCDT; // Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_SCD4CR_SCDACTIVE = 0x80000000; // SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_DFLT4IER_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT4IER_FTHIE = 0x1; // RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
    static constexpr uint32_t MDF_DFLT4IER_DOVRIE = 0x2; // Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
    static constexpr uint32_t MDF_DFLT4IER_SSDRIE = 0x4; // Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
    static constexpr uint32_t MDF_DFLT4IER_OLDIE = 0x10; // Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
    static constexpr uint32_t MDF_DFLT4IER_SSOVRIE = 0x80; // Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
    static constexpr uint32_t MDF_DFLT4IER_SCDIE = 0x100; // Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
    static constexpr uint32_t MDF_DFLT4IER_SATIE = 0x200; // Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
    static constexpr uint32_t MDF_DFLT4IER_CKABIE = 0x400; // Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
    static constexpr uint32_t MDF_DFLT4IER_RFOVRIE = 0x800; // Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled

    static constexpr uint32_t MDF_DFLT4ISR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT4ISR_FTHF = 0x1; // RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT4ISR_DOVRF = 0x2; // Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT4ISR_SSDRF = 0x4; // Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT4ISR_RXNEF = 0x8; // RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
    static constexpr uint32_t MDF_DFLT4ISR_OLDF = 0x10; // Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
    static constexpr uint32_t MDF_DFLT4ISR_THLF = 0x20; // Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
    static constexpr uint32_t MDF_DFLT4ISR_THHF = 0x40; // High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
    static constexpr uint32_t MDF_DFLT4ISR_SSOVRF = 0x80; // Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT4ISR_SCDF = 0x100; // Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT4ISR_SATF = 0x200; // Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT4ISR_CKABF = 0x400; // Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT4ISR_RFOVRF = 0x800; // Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.

    static constexpr uint32_t MDF_OEC4CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OEC4CR_OFFSET; // Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.


    static constexpr uint32_t MDF_SNPS4DR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x1ff> MDF_SNPS4DR_MCICDC; // Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
    typedef bit_field_t<9, 0x7f> MDF_SNPS4DR_EXTSDR; // Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
    typedef bit_field_t<16, 0xffff> MDF_SNPS4DR_SDR; // Contains the 16 MSB of the last valid data processed by the digital filter.

    static constexpr uint32_t MDF_DFLT4DR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<8, 0xffffff> MDF_DFLT4DR_DR; // Data processed by digital filter.


    static constexpr uint32_t MDF_SITF5CR_RESET_VALUE = 0x1f00; // Reset value
    static constexpr uint32_t MDF_SITF5CR_SITFEN = 0x1; // Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
    typedef bit_field_t<1, 0x3> MDF_SITF5CR_SCKSRC; // Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x3> MDF_SITF5CR_SITFMOD; // Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x1f> MDF_SITF5CR_STH; // Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_SITF5CR_SITFACTIVE = 0x80000000; // Serial interface Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the serial interface is effectively enabled (active) or not. The protected fields of this function can only be updated when the SITFACTIVE is set , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SITFEN and a transition on SITFACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The serial interface is not active, and can be configured if needed - 1: The serial interface is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_BSMX5CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x1f> MDF_BSMX5CR_BSSEL; // Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_BSMX5CR_BSMXACTIVE = 0x80000000; // BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set to . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set to in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_DFLT5CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT5CR_DFLTEN = 0x1; // Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
    static constexpr uint32_t MDF_DFLT5CR_DMAEN = 0x2; // DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT5CR_FTH = 0x4; // RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x7> MDF_DFLT5CR_ACQMOD; // Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT5CR_TRGSENS = 0x100; // Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0xf> MDF_DFLT5CR_TRGSRC; // Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT5CR_SNPSFMT = 0x10000; // Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<20, 0xff> MDF_DFLT5CR_NBDIS; // Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT5CR_DFLTRUN = 0x40000000; // Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
    static constexpr uint32_t MDF_DFLT5CR_DFLTACTIVE = 0x80000000; // Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active

    static constexpr uint32_t MDF_DFLT5CICR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3> MDF_DFLT5CICR_DATSRC; // Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x7> MDF_DFLT5CICR_CICMOD; // Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x1ff> MDF_DFLT5CICR_MCICD; // CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<20, 0x3f> MDF_DFLT5CICR_SCALE; // Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits

    static constexpr uint32_t MDF_DFLT5RSFR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT5RSFR_RSFLTBYP = 0x1; // Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT5RSFR_RSFLTD = 0x10; // Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_DFLT5RSFR_HPFBYP = 0x80; // High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<8, 0x3> MDF_DFLT5RSFR_HPFC; // High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_DFLT5INTR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3> MDF_DFLT5INTR_INTDIV; // Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0x7f> MDF_DFLT5INTR_INTVAL; // Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_OLD5CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_OLD5CR_OLDEN = 0x1; // Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
    static constexpr uint32_t MDF_OLD5CR_THINB = 0x2; // Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<4, 0xf> MDF_OLD5CR_BKOLD; // Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0x3> MDF_OLD5CR_ACICN; // OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<17, 0x1f> MDF_OLD5CR_ACICD; // OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_OLD5CR_OLDACTIVE = 0x80000000; // OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_OLD5THLR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OLD5THLR_OLDTHL; // OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.

    static constexpr uint32_t MDF_OLD5THHR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OLD5THHR_OLDTHH; // OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details

    static constexpr uint32_t MDF_DLY5CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x7f> MDF_DLY5CR_SKPDLY; // Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
    static constexpr uint32_t MDF_DLY5CR_SKPBF = 0x80000000; // Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.

    static constexpr uint32_t MDF_SCD5CR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_SCD5CR_SCDEN = 0x1; // Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
    typedef bit_field_t<4, 0xf> MDF_SCD5CR_BKSCD; // Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    typedef bit_field_t<12, 0xff> MDF_SCD5CR_SCDT; // Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    static constexpr uint32_t MDF_SCD5CR_SCDACTIVE = 0x80000000; // SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.

    static constexpr uint32_t MDF_DFLT5IER_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT5IER_FTHIE = 0x1; // RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
    static constexpr uint32_t MDF_DFLT5IER_DOVRIE = 0x2; // Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
    static constexpr uint32_t MDF_DFLT5IER_SSDRIE = 0x4; // Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
    static constexpr uint32_t MDF_DFLT5IER_OLDIE = 0x10; // Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
    static constexpr uint32_t MDF_DFLT5IER_SSOVRIE = 0x80; // Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
    static constexpr uint32_t MDF_DFLT5IER_SCDIE = 0x100; // Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
    static constexpr uint32_t MDF_DFLT5IER_SATIE = 0x200; // Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
    static constexpr uint32_t MDF_DFLT5IER_CKABIE = 0x400; // Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
    static constexpr uint32_t MDF_DFLT5IER_RFOVRIE = 0x800; // Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled

    static constexpr uint32_t MDF_DFLT5ISR_RESET_VALUE = 0x0; // Reset value
    static constexpr uint32_t MDF_DFLT5ISR_FTHF = 0x1; // RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT5ISR_DOVRF = 0x2; // Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT5ISR_SSDRF = 0x4; // Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT5ISR_RXNEF = 0x8; // RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
    static constexpr uint32_t MDF_DFLT5ISR_OLDF = 0x10; // Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
    static constexpr uint32_t MDF_DFLT5ISR_THLF = 0x20; // Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
    static constexpr uint32_t MDF_DFLT5ISR_THHF = 0x40; // High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
    static constexpr uint32_t MDF_DFLT5ISR_SSOVRF = 0x80; // Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT5ISR_SCDF = 0x100; // Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT5ISR_SATF = 0x200; // Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT5ISR_CKABF = 0x400; // Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
    static constexpr uint32_t MDF_DFLT5ISR_RFOVRF = 0x800; // Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.

    static constexpr uint32_t MDF_OEC5CR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x3ffffff> MDF_OEC5CR_OFFSET; // Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.


    static constexpr uint32_t MDF_SNPS5DR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<0, 0x1ff> MDF_SNPS5DR_MCICDC; // Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
    typedef bit_field_t<9, 0x7f> MDF_SNPS5DR_EXTSDR; // Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
    typedef bit_field_t<16, 0xffff> MDF_SNPS5DR_SDR; // Contains the 16 MSB of the last valid data processed by the digital filter.

    static constexpr uint32_t MDF_DFLT5DR_RESET_VALUE = 0x0; // Reset value
    typedef bit_field_t<8, 0xffffff> MDF_DFLT5DR_DR; // Data processed by digital filter.
};

template<>
struct peripheral_t<STM32U5xx, MDF1>
{
    static constexpr periph_t P = MDF1;
    using T = stm32u5xx_mdf1_t;
    static T& V;
};

template<>
struct peripheral_t<STM32U5xx, SEC_MDF1>
{
    static constexpr periph_t P = SEC_MDF1;
    using T = stm32u5xx_mdf1_t;
    static T& V;
};

using mdf1_t = peripheral_t<svd, MDF1>;
using sec_mdf1_t = peripheral_t<svd, SEC_MDF1>;

template<int INST> struct mdf_traits {};

template<> struct mdf_traits<1>
{
    using mdf = mdf1_t;
    static constexpr signal_t CCK0 = MDF1_CCK0;
    static constexpr signal_t CCK1 = MDF1_CCK1;
    static constexpr signal_t CKI0 = MDF1_CKI0;
    static constexpr signal_t CKI1 = MDF1_CKI1;
    static constexpr signal_t CKI2 = MDF1_CKI2;
    static constexpr signal_t CKI3 = MDF1_CKI3;
    static constexpr signal_t CKI4 = MDF1_CKI4;
    static constexpr signal_t CKI5 = MDF1_CKI5;
    static constexpr signal_t SDI0 = MDF1_SDI0;
    static constexpr signal_t SDI1 = MDF1_SDI1;
    static constexpr signal_t SDI2 = MDF1_SDI2;
    static constexpr signal_t SDI3 = MDF1_SDI3;
    static constexpr signal_t SDI4 = MDF1_SDI4;
    static constexpr signal_t SDI5 = MDF1_SDI5;
};
